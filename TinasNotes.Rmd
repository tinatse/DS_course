#TINA NOTES

####create a matrix
```{create a matrix}
> m <- matrix(nrow = 2, ncol = 3)
> m
 [,1] [,2] [,3]
[1,] NA NA NA
[2,] NA NA NA
> dim(m)
[1] 2 3
> attributes(m)
$dim
[1] 2 3

> m <- matrix(1:6, nrow = 2, ncol = 3)
> m
 [,1] [,2] [,3]
[1,] 1 3 5
[2,] 2 4 6
```


####subset data
```{subset data}
x <- c("a", "b", "c", "c", "d", "a")

u = x == "a"
x[u]


x <- list(foo = 1:4, bar = 0.6, baz = "hello")
name <- "foo"

x[[name]] 
x$foo

x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))


#first column, third row
x[[c(1, 3)]]
x[[1]][[3]]

#second column, first row
x[[c(2, 1)]]

```
<<<<<<< HEAD

####Partial matching of names is allowed with [[ and $.
```{Partial matching of names is allowed with [[ and $}
x <- list(aardvark = 1:5)
x$a
x[["a"]]
x[["a", exact = FALSE]]
```

####For Loops
######these loops do the same thing
```{For Loops}
x = c("a","b","c","d")

for(i in 1:4){
  print(x[i])
}

for(i in seq_along(x)) {
  print(x[i])
}


for(letter in x){
  print(letter)
}

for(i in 1:4) print(x[i])
```


####Coding Standards
######Define indenting and max code length
```{Define indenting and max code length}
#Preferences > Code > Tab width 4
#Cmd+i indent

#Preferences > Code > Display > Margin Column 80
```


Dates and Times
```{Dates and Times}
#Classes for dates: 
#Dates are represented by Date
#Times are represented by POSIXct or POSIXlt
#Dates are stored internally as the number of days since 1970-01-01
#Times are stored internally as the number of seconds since 1970-01-01

#From character string to Date
#as.Date("1970-01-01")

#POSIXlt stores days of the week, day of the year, month, day of the month

#Functions that work on dates and time:
#weekdays : give the day of the week
#months: give the month name
#quarters: give the quarter number ("Q1","Q2","Q3","Q4")

#You can use as.POSIXct or as.POSIXlt function to coerce character into time
x <- Sys.time()
p <- as.POSIXlt(x)
names(unclass(p))
p$sec


#strptime function dates with different formats
datestring = c("January 10, 2012 10:40",
               "December 9, 2011 9:10")

x = strptime(datestring, "%B %d, %Y %H:%M")
x

class(x)

#For more formatting strings: 
?strptime 

```


####Operations on Dates and Times
```{Operations on Dates and Times}
#You can use mathematical operations on dates and times. You can use +, -, <=, >=, #<, > or =
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S")
x-y

x <- as.POSIXlt(x)
x-y


#Time difference
x <- as.Date("2012-03-01")
y <- as.Date("2012-02-28")
x-y
## Time difference of 2 days
x <- as.POSIXct("2012-10-25 01:00:00")
y <- as.POSIXct("2012-10-25 06:00:00", tz = "GMT")
y-x
```

#### Select range of columns
```{Select range of columns}
#select columns from r_arch to country
select(cran, r_arch:country)

#works the other way around too
select(cran, country:r_arch)

Remove time column from cran data frame
select(cran, -time)

Sequence from -5 to -20
-(5:20)
```


####Filter for one condition or the other
```{Filter for one condition or the other}
filter(cran, country == "US" | country == "IN")
```

####lapply
```{lapply}
#lapply: Loop over a list and evaluate a function on each element
#lapply takes three arguments: (1) a list X; (2) a function (or the name of a #function) FUN; (3) other
#arguments via its ... argument. If X is not a list, it will be coerced to a list #using as.list.
#lapply always returns a list, regardless of the class of the input.

#apply mean to x
x = list(a =  1:5, b=rnorm(10))
lapply(x, mean)

x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)

x <- 1:4
lapply(x, runif)

#anonymous functions
#write functions on the fly then the function disappears
#function(elt) call the elt function
#elt[,1] selects the first column
lapply(x, function(elt) elt[,1])
```


####sapply
```{sapply}
#sapply: Same as lapply but try to simplify the result
#sapply can return a vector
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean)
```

####
######
```{}
#apply: Apply a function over the margins of an array
#tapply: Apply a function over subsets of a vector
#mapply: Multivariate version of lapply
```


####
######
```{}

```